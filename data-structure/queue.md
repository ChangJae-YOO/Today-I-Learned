# Queue

## Queue의 특성
- 삽입, 삭제의 위치가 제한적인 자료구조
- 큐 뒤 : 삽입 / 큐 앞 : 삭제
- 선입선출구조 (FIFO)
- 큐의 예 : 서비스 대기 행렬
- 큐의 앞쪽 : front, 큐의 뒤쪽 : rear

## Queue의 주요 연산
- enQueue : 큐의 뒤쪽에 원소를 삽입하는 연산
- deQueue : 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산
- createQueue : 공백 상태의 큐를 생성하는 연산
- isEmpty : 큐가 공백상태인지를 확인하는 연산
- isFull : 큐가 포화상태인지를 확인하는 연산
- Qpeek() : 큐의 앞쪽(front)에서 원소를 삭제 없이 반환하는 연산

## Queue의 연산 과정
- 공백 큐 생성 : createQueue();
- 원소 A 삽입 : enQueue(A);
- 원소 B 삽입 : enQueue(B);
- 원소 반환/삭제 : deQueue();

## Queue의 종류
- 선형 큐, 원형 큐 : 리스트를 사용하여 구현
- 연결 큐 : 연결리스트 형식을 이용
- 우선순위 큐 : 큐를 응용

## 선형 큐의 특징
- 1차원 리스트를 이용한 큐
- 큐의 크기 = 리스트의 크기
- front : 저장된 첫 번째 원소의 인덱스
- rear : 저장된 마지막 원소의 인덱스
- 초기상태 front = rear = -1, 공백 상태 fron = rear, 포화 상태 rear = n-1

## 선형 큐의 구현
- 초기 공백 큐 생성 front, rear = -1, 1차원 리스트 초기화
- 삽입 : rear값을 하나 증가시켜 새로운 원소를 삽입할 자리 마련, Q[rear]에 item 저장
- 삭제 : front 값을 하나 증가시켜 큐에 남아있는 첫번째 원소로 이동함 새로운 원소를 리턴함으로써 삭제와 동일한 기능을 함
- 공백상태 및 포화상태 검사 : 공백상태 - front = rear, 포화상태 - rear = n - 1
- 검색 : 가장 앞에 있는 원소를 검색하여 반환하는 연산

## 선형 큐의 문제점
- 잘못된 포화 상태 인식!
- 리스트의 크기를 고정, 메모리 낭비 발생
- 삽입, 삭제의 처리속도가 빠르지만 메모리 낭비가 심함
- 원형 큐 사용으로 메모리를 절약할 수 있음
- 파이썬의 이스트 특성을 사용한 큐 사용으로 메모리 절약
- 단순연결 리스트로 메모리 확보 가능
- 큐 라이브러리 사용으로 해결 가능

## 원형 큐
- 1차원 리스트를 사용하되, 논리적으로 리스트의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정하고 사용함
- 원형 큐의 논리적 구조

## 원형 큐의 특징
- 초기 공백 상태 : front = rear = 0
- index의 순환 : front와 rear의 위치가 리스트의 마지막 인덱스인 n - 1을 가리킨 후, 논리적 순환을 이루어 리스트의 처음 인덱스인 0으로 이동해야 함
- 이를 위해 나머지 연산자 %를 사용
- front 변수 : 공백 상태와 포화 상태 구분을 쉽게 하기 위해 front가 있는 자리는 사용하지 않고 항상 빈 자리로 둠
- 원형 큐 삽입 삭제 위치 : rear = (rear + 1) % n, front = (front + 1) % n

## 원형 큐의 구현
- 초기 공백큐 생성 : 크기 n인 1차원 리스트 생성, front rear = 0으로 초기화
-  공백상태 및 포화상태 검사 : 공백상태 - front = rear, 포화상태 : 삽입할 rear의 다음 위치 = 현재 front
-  원소 삽입 : rear 값에 나머지 연산을 통해 다음 위치를 마련함
-  원소 삭제 : front 값을 조정하여 삭제할 자리를 준비, 새로운 front 원소를 리턴함으로써 삭제와 같은 기능을 함

## 파이썬의 리스트 특성을 사용한 큐
- 리스트는 크기를 동적으로 변경할 수 있음
- 메모리 절약
- 삽입, 삭제 시 복사, 데이터를 이동시키는 연산을 수행하는데 많은 시간 소모

## 연결 큐의 특징
- 단순 연결 리스트를 이용한 큐
- 큐의 원소 : 단순 연결 리스트의 노드
- 큐의 원소 순서 : 노드의 연결 순서, 링크로 연결되어 있음
- front : 첫 번째 노드를 가리키는 링크
- rear : 마지막 노드를 가리키는 링크
- 상태 표현 : 초기상태 front = rear = None , 공백상태 front = rear = None
  
## 연결 큐의 연산 과정
- 큐 생성 : front, rear None으로 초기화
- 원소 삽입 : front : A의 위치 rear : A의 위치
- 원소 삭제 : front A대신 다음 노드를 가리키면 됨

## 연결 큐의 구현
- 초기 공백 큐 생성 : 리스트 노드 없이 포인터 변수만 생성 front = rear = None
- 공백 상태 검사 : 공백 상태 front = rear = None
- 삽입 : 새로운 노드를 생성 front, rear 변수 지정
- 삭제 : front 재설정, 삭제 후 공백 큐가 되는 경우 rear도 None값으로 설정

## 큐 모듈
- 선입 선출, 선입 후출, 우선순위 큐... 구현이 되어있음

## 우선순위 Queue
- 우선순위를 가진 항목들을 저장하는 큐
- FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나가게 됨
- 시뮬레이션 시스템, 네트워크 트래픽 제어, 운영체제의 태스크 스케줄링

## 리스트를 이용한 우선순위 큐의 구현
- 리스트를 이용하여 자료 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
- 가장 앞에 최고 우선순위의 원소가 위치하게 됨
- 리스트를 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생
- 소요되는 시간이 많이 걸림

## 버퍼
- 데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역
- 버퍼링 : 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 의미
- 버퍼의 자료구조 : 일반적으로 입출력 및 네트워크와 관련된 기능에서 이용
- 순서대로 입력 출력 전달 되어야 하므로 FIFO방식의 자료구조인 큐가 사용됨

## 버퍼 활용 - 키보드 버퍼의 수행 과정
- 키보드 입력 버퍼에 Enter 키 입력이 들어오기 전까지 버퍼에 저장
- 엔터키 입력이 들어오면 프로그램 실행 영역으로 가 연산을 수행

## BFS 너비 우선 탐색
- 그래프 탐색 방법 : DFS (스택 활용), BFS (큐 활용)
- 시작점의 인접한 정점들을 모두 차례로 방문한 후 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식