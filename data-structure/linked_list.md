# Linked List

## List
- 순서를 가진 데이터의 묶음 : 같은 데이터의 중복 저장 가능
- 시퀀스 자료형 : 인덱싱, 슬라이싱, 연산자, 메서드 사용 가능
- 크기제한 없음, 타입제한 없음
- 순차 리스트 : 배열을 기반으로 구현된 리스트
- 연결 리스트 : 메모리의 동적할당을 기반으로 구현된 리스트

## 순차 리스트
- 초기화 및 생성 : 변수에 값을 초기화하는 것으로 리스트 생성
- 데이터 접근 : 리스트의 인덱스를 이용해 원하는 위치의 데이터를 변경하고 참조할 수 있음
- 리스트 : 동적 배열로 작성된 순차 리스트
- 자료의 삽입 삭제 연산 : 원소의 이동 작업이 필요
- 원소의 개수가 많고 삽입/삭제 연산이 빈번한 작업 : 소요되는 시간이 크게 증가

## 리스트 복사
- 여러 가지 방법으로 리스트 복사
- 수행시간의 차이가 있고, 의미가 다른 항목 존재
- new_list = old_list : 주소의 복사, 얕은 복사
- new_list = old_list[:] : 슬라이싱, 깊은 복사
- new_list = [], new_list.extend(old_list) : 리스트를 추가하는 함수 깊은 복사
- new_list = list(old_list) : list(), 깊은복사
- import copy 사용
- 리스트 함축, 깊은 복사
- 리스트 원소까지도 깊은 복사 deepcopy 사용 : 가장 느림

## 연결 리스트
- 리스트의 단점을 보완한 자료 구조
- 자료의 논리적인 순서와 메모리 상의 물리적인 순서가 일치하지 않고, 개별적으로 위치하고 있는 원소의 주소를 연결하여 하나의 전체적인 자료구조를 이룸
- 링크를 통해 원소에 접근하므로, 순차 리스트에서 물리적인 순서를 마추기 위한 작업이 필요하지 않음
- 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적인 사용이 가능
- 탐색 - 순차탐색
- 노드 : 연결 리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료단위, 데이터 필드, 링크 필드 존재
- 헤드 : 리스트의 처음 노드를 가리키는 링크 필드

## 연결 리스트 사용을 위한 주요 함수
- addtoFirst() : 연결 리스트의 앞쪽에 원소를 추가하는 연산
- addtoLast() : 연결 리스트의 뒤쪽에 원소를 추가하는 연산
- add() : 연결 리스트의 특정 위치에 원소를 추가하는 연산
- delete() : 연결 리스트의 특정 위치에 있는 원소를 삭제하는 연산
- get() : 연결 리스트의 특정 위치에 있는 원소를 리턴하는 연산

## 단순 연결 리스트
- 노드가 하나의 링크 필드에 의해 다음 노드와 연결되는 구조를 가짐
- 헤드가 가장 앞의 노드를 가리키고, 각 노드의 링크 필드가 연속적으로 다음 노드를 가리킴
- 최종적으로 None을 가리키는 노드가 리스트의 가장 마지막 노드임

## 단순 연결 리스트의 삽입 연산
- 메모리를 할당하여 새로운 노드 new 생성임
- 새로운 노드 new의 데이터 필드에 'B' 저장
- 삽입될 위치의 바로 앞에 위치한 노드의 링크필드를 생성된 노드에 복사
- new의 주소를 앞 노드의 링크필드에 복사

## 단순 연결 리스트의 삭제 연산
- 삭제할 노드의 앞 노드 탐색
- 삭제할 노드의 링크 필드를 선행 노드의 링크필드에 복사

## 이중 연결 리스트
- 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
- 두 개의 링크 필드와 한 개의 데이터 필드로 구성

## 삽입 정렬
- 도서관 사서가 책을 정렬할 때 일반적으로 활용되는 방식
- 자료 배열의 모든 원소들을 앞에서부터 차례대로 미이 정렬된 부분과 비교하여, 자신의 위치를 찾아냄으로써 정렬을 완성

## 삽입 정렬의 정렬 과정
- 정렬할 자료를 두 개의 부분집합 S와 U로 가정
- 부분집합 S : 정렬된 앞부분의 원소들
- 부분집합 U : 아직 정렬되지 않은 원소들
- 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내서 이미 정렬되어있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입
- 삽입 정렬을 반복하면서 부분집합S의 원소는 하나씩 늘리고 부분집합 U의 원소는 하나씩 감소하게 함
- 부분집합 U가 공집합이 되면 삽입정렬이 완성됨

## 병합 정렬
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 분할 정복 알고리즘 활용 : 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄, Top-Down 방식
- 시간 복잡도 : O(nlogn)

## Linked List의 활용
- List를 이용한 Stack : 스택 내의 순서는 리스트의 링크를 통해 연결됨
- Push : 리스트의 마지막에 노드 삽입
- Pop : 리스트의 마지막 노드 반환 / 삭제
- Top : 리스트의 마지막 변수를 가리킴

## Linked List를 이용한 Stack의 활용
- Push, Pop, Top, 링크드 리스트로 구현

## 순차 리스트를 이용한 우선순위 큐 구현
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
- 배열 대비 장점 : 삽입 / 삭제 연산 이후 원소의 재배치가 필요 없음, 메모리의 효율적인 사용이 가능함
