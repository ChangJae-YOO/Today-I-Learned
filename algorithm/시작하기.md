# 시작하기

## 프로그래밍하기 위한 제약 조건과 요구사항
- 프로그래밍 언어의 특성
- 프로그램이 동작할 H/W와 OS에 관한 지식
- 라이브러리들의 유의 사항들
- 프로그램이 사용할 수 있는 최대 메모리
- 사용자 대응 시간 제한
- 재사용성이 높은 간결한 코드

## SW 문제 해결 역량
- 프로그램 작성을 위한 많은 제약 조건들과 요구사항들을 이해하고 최선의 방법을 찾아내는 능력
- 프로그래머가 사용하는 언어, 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 연결하여 큰 그림을 만드는 능력
- 문제 해결 역량은 추상적인 기술

## 문제 해결 능력을 향상시키는 훈련
- 새로운 언어, 프레임워크, 개발 방법론들의 조합 방법을 배워야 함
- 프로그래밍 경험을 통해서 나아질 것이라는 기대를 하지 않아야 함    
  (경험에서 문제 해결능력 개발 가능한 상황이 주어지지 않음)   
  (문제 해결 능력 개발 가능한 상황에서 자기 계발하기 어려움)
- 인위적 상황을 만들어 훈련해야 함  
  (정제된 추상적인 문제를 제시하고 해결하면서 문제 해결 능력을 향상시킬 수 있는 훈련 필요)

## 문제 해결 과정 단계
- 문제 읽고 이해하기
- 문제를 익숙한 용어로 재정의하기
- 어떻게 해결할지 계획 세우기
- 계획 검증하기
- 프로그램으로 구현하기
- 풀이를 톨아보고, 개선할 방법 찾기
- (멀리 갈 필요 없이 내가 수학문제 풀 때 어떻게 했었는지 떠올려 보자)

## 문제 해결 전략
- 직관과 체계적인 접근
- 체계적인 접근을 위한 질문들
- 비슷한 문제를 풀어본 적이 있던가?
- 단순한 방법에서 시작할 수 있을까?
- 문제를 단순화 할 수 있을까?, 그림으로 그려 볼 수 있을까?, 수식으로 표현 할 수 있을까?
- 문제를 분해 할 수 있을까?
- 뒤에서부터 생각해서 문제를 풀 수 있을까?
- 특정 형태의 답만을 고려할 수 있을까?

## 알고리즘
- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
- 주로 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
- 어떠한 문제를 해결하기 위한 절차

## 알고리즘의 효율
- 같은 문제에 대한 다른 알고리즘들이 구현되어 컴퓨터에서 실행되는 경우
- 입력이 커질 수록 알고리즘의 효율에 따라 실행 시간의 차이 발생
- 공간적 효율성 : 얼마나 많은 메모리 공간을 요하는가?
- 시간적 효율성 : 얼마나 많은 시간을 요하는가?
- 효율성은 복잡도(Complexity)로 표현 가능, 복잡도가 높을수록 효율 감소

## 시간적 복잡도 분석
- 하드웨어 환경에 따라 처리시간 달라짐
- 소프트웨어 환경에 따라 처리시간 달라짐
- 환경적 차이로 인해 분석 어려움
- 시간 복잡도의 점근적 표기 : 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위한 표기법
- O(Big-Oh) - 표기, (Big-Omega) -표기, (Theta) -표기

## 점근적 상한
- O-표기는 복잡도의 점근적 상한을 나타냄
- 최고 차항만 나타냄
- 오메가-표기는 점근적 하한을 의미 (최소한 이만한 시간을 걸린다는 것을 의미)
- 세타-표기는 O-표기와 오메가-표기가 같은 경우에 사용 (n^2과 동일한 증가율을 가짐을 의미)

## 왜 효율적인 알고리즘이 필요할까?
- 효율적인 알고리즘은 슈퍼컴퓨터보다 더 큰 가치가 있음
- 값 비싼 H/W의 기술 개발보다 효율적인 알고리즘 개발이 더 경제적

## 비트 연산
- 비트 연산자는 다른 연산자들에 비해 시간이 적게 소요됨
- 프로그램에서 비트 연산 적용 시 연산 속도를 향상시키거나 메모리 절약 가능

## 1 << n
- 2^n 값을 가짐
- 원소가 n개일 경우의 모든 부분집압의 수를 의미
- Power set (모든 부분 집합)

## 1 & (1 << j)
- 계산 결과는 i의 j번째 배트가 1인지 아닌지를 의미

## 비트 연산 1 (특정 위치의 비트값을 확인하는 수식에 대한 예제)
```
def BitPrint(i):
  for j in range(7, -1, -1):
    print('1' if (i & (1 << j))) else '0', end = "")

for i in range(-5, 6):
  print("%2d = " %i, end = "")  # 십진수 출력
  BitPrint(i)  #이진수 출력
  print()
```

## 비트 연산 2 (4바이트 크기의 인트형 변수에 저장된 값들을 한 바이트씩 읽어서 비트 형태로 출력하는 예제)
```
a = 0x10  #16 진수 표현
x = 0x01020304

print("%d = " %a, end = "")
BitPrint(a)
print()

print("%08x = " %x, end = "")
for i in range(0, 25, 8):
  BitPrint(x >> i)
  print(end = " ")
```

## 엔디안 (Endianness)
- 컴퓨터 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 의미하며 HW 아키텍처마다 다름
- 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 않으면 오류를 발생시킬 수 있음
- Big-endian : 보통 큰 단위가 앞에 나옴, 네트워크에 사용
- Little-endian : 작은 단위가 앞에 나옴, 대다수 데스크탑 컴퓨터

## 비트 연산 3 (자신의 컴퓨터카 어떤 엔디안 방식인지 확인하는 코드)
```
n = 0x00111111

if n & 0x11:
  print("little endian")

else:
  print("big endian")
```

## 비트 연산 4 (비트 연산자 ^를 두번 연산하면 처음 값을 반환)
```
a = 0x86
key = 0xAA
print("a   ==>", end="")
BitPrint(a)
print()
print("a^=key==> ", end = "")
a ^= key
BitPrint(a)
print()
print("a^=key==>", end = "")
a ^= key
BirPrint(a)
print()
```

## 진법 변환
- 문제 해결을 위해서 진수 변환이 필요한 경우
- 자주 사용되는 진수들 - 2진수, 8진수, 10진수, 16진수
- 10진수를 타 진수로 변환하는 방법
- 원하는 타진법의 수로 나는뒤 나머지를 거꾸로 읽으면 됨
- 타 진수를 10진수로 변환하는 방법 : 각 자릿값을 행당 진수의 값을 곱해서 구함
- 2진수, 8진수, 16진수간 변환 : 비트 단위로 묶음을 변화시켜 변환가능

## 컴퓨터에서의 음의 정수 표현 방법
- 1의 보수 : 부호와 절대값으로 표현된 값을 부호 비트를 제외 한 나머지 비트들을 0은 1로, 1은 0로 변환
- 2의 보수 : 1의 보수방법으로 표현된 값의 최하의 뷔트에 1을 더함

## 실수
- 컴퓨터에서의 실수의 표현 방법
- 2진 실수를 10진수로 변환하는 방법 : 진수 변환과 동일
  
## 컴퓨터에서의 실수 표현 방법 
- 부동 소수점 (Floating-point) 표기법 사용
- 소수점의 위치를 고정시켜 표현하는 방식
  
## 컴퓨터에서의 실수 저장 형식
- 단정도 실수(32비트) : 부호 1비트, 지수 8비트, 가수 23비트
- 배정도 실수(62비트) : 부호 1비트, 지수 11비트, 가수 52비트
- 가수부 : 실수의 유효 자릿수들을 부호화된 고정 소수점으로 표현한 것
- 지수부 : 실제 소수점의 위치를 지수 승으로 표현한 것

## 단정도 실수의 가수 부분을 만드는 방법 
- 지수부에는 8비트가 배정 (256개의 상태를 나타낼 수 있음)
- 숫자로 0 - 255까지 나타낼 수 있지만, 음수 값을 나타낼 수 있어야 하기 때문에 익세스 표현법 사용 : 지수부의 값을 반으로 나누어 그 값을 0으로 간주하여 음수지수와 양수지수를 표현하는 방법

## 컴퓨터는 실수를 근사적으로 표현
- 이진법으로 표현 할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장
- 근사값으로 저장될 때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져옴

## 실수 자료형의 유효 자릿수
- 단정도 : 6
- 배정도 : 15