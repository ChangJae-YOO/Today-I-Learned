# List1 (2023-01-16) (SW Expert Academy)

## 알고리즘 개요
- 알고리즘이란 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법이다.

## 알고리즘 표현법
- 슈도코드(의사코드)
- 순서도

## 무엇이 좋은 알고리즘인가?
- 정확성 (얼마나 정확하게 동작하는가?)
- 작업량 (얼마나 적은 연산을 하는가?)
- 메모리 사용량 (얼마나 적은 메모리를 사용하는가?)
- 단순성 (얼마나 단순한가?)
- 최적성 (개선의 여지가 없는가?)

## 알고리즘 성능 분석의 필요
- 알고리즘의 작업량을 비교
- 작업량을 표현할 때 시간복잡도를 이용
- 빅-오(O) 표기법
- 빅-오에 차수에 따라 실행시간이 지수적으로 변하므로 주의해야됨.
- N = 1억 -> NlogN = 2.66초, N^2 = 115.7days

## python 소개
- 인터프리터 언어로 독립적인 플랫폼에서도 사용 가능
- 객체지향
- 하드웨어의 성능 개선으로 실행속도보다 생산성에 관심이 생기며 급부상
- 모든 자료는 객체
- 변수의 선언은 따로 없음 

## python 자료형
- 다수의 데이터를 저장할 수 있는 컨테이너
- 컨테이너 : tuple, list, dictionary, set 

## 배열(List)
- 같은 타입 변수들을 하나의 이름으로 열거하여 사용하는 자료구조
- 리스트를 사용하면 하나의 변소로 대량의 데이터를 효율적으로 처리가능
- 시퀀스 자료형의 하나 (indexing, slicing 사용 가능)
- 시퀀스 내장연산,함수 (len, +, *, in, not in, min, max, sorted )
- 시퀀스 내장함수 (append, insert, pop, remove, count)
- 리스트 함축 ex) i for i in [2, 3, 4, 5, 6] if i % 2 == 0

## 완전 검색 (Exhaustive Search)
- Brute-force, Generate and Test 기법이라고도 불림
- 모든 경우의 수를 테스트 한 후, 최종 해법을 도출 함
- 일반적으로 경우의 수가 상대적으로 작을 때 유용함
- 수행속도는 느리지만 해답을 찾지 못 할 확률이 작음
- 문제를 풀 때 완전 검색으로 접근한 다음 개선하는 것이 바람직함

## 순열 (Permutation)
- 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
- 완전 검색으로 모든 순열 만들기
- ex) baby-gin

## 탐욕 알고리즘 (Greedy Algorithm)
- 최적 해를 구하는데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 최적이라고 생각되는 것은 택
- 최적이라는 보장은 없음
  
## 탐욕 알고리즘 수행 과정
- 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤 집합에 추가
- 신행 가능성 검사 : 문제의 제약 조건을 위반하지 않는지를 검사
- 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지를 확인
- 다시 시작 : 문제의 해가 완성되지 않았다면 다시 시작함.
- ex) 거스름돈 줄이기, baby-gin

## 정렬(Sort)
- 2개 이상의 자료를 특정 기준에 의해 오름차순 또는 내림차순으로 재배열 하는 것
- 여기서 키란 자료를 정렬하는 기준이 되는 특정 값 (ex : 서류번호)
- 정렬 종류 : 버블 정렬, 카운팅 정렬, 선택 정렬, 퀵 정렬, 삽입 정렬, 병합 정렬

## 버블 정렬
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 자리 이동
- 한 단계가 끝나면 가장 큰 원소 또는 작은 원소가 마지막 자리로 정렬
- 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품모양 같아서 버블 정렬이라고 함
- 시간 복잡도 = O(n^2)
- 시간 될 때 정확도를 증명해보자.
  
## 카운팅 정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
- 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 시간 복잡도 = O(n+k) n : 리스트의 개수, k : 정수의 최대값
- 실제 실행방식이 독창적이다... 한번 해봐야 기억에 남을 듯